<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Sudoku Auswahl</title>

    <!-- PDF & Screenshot Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="node_modules/jspdf.umd.min.js"></script>
    <script src="node_modules/svg2pdf.umd.min.js"></script>

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            background-image: url('https://www.bund-nrw.de/fileadmin/nrw/bilder/Naturschutz/Biber/Biber_an_gefaelltem_Baumstamm_-_Leopold_Kanzler_gross_01.jpg');
            background-size: cover;
        }


        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .controls2 {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .controls3 {
            display: flex;
            gap: 10px; /* Abstand zwischen den Elementen */
            align-items: center; /* Vertikal zentrieren */
            margin-bottom: 1rem;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        button, select {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            background-color: #eee;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        .active-mode {
            background-color: dodgerblue;
            color: white;
        }

        button.active-mode:hover{
            background-color: dodgerblue;
            color:white;
        }

        button:hover, select:hover {
            background-color: #ddd;
        }

        .grid-wrapper {
            position: relative;
            display: inline-block;
        }

        .background {
            position: absolute;
            inset: 0;
            background-color: white;
            background-size: cover;
            background-position: center;
            filter: grayscale(100%);
            z-index: 0;
            pointer-events: none;
        }

        .grid {
            position: relative;
            display: grid;
            z-index: 1;
            gap: 0;
            margin-bottom: 0rem;
        }

        .cell.error {
            background-color: rgba(255, 154, 154, 0.5);
            color: white;
            transition: background-color 0.3s ease; /* sanfte Animation */
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid black;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            user-select: none;
            box-sizing: border-box;
        }

        .cell.marked {
            background-color: rgba(30, 144, 255, 0.5);
            color: white;
        }

        .cell input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 2.5rem;
            background: transparent;
        }

        .cell input:focus {
            outline: none;
            background-color: transparent;
        }

        .cell.ausgabe {
            background-color: gray;
            font-weight: bold;
            font-size: xx-large;
        }

        .thick-top { border-top: 4px solid black !important; }
        .thick-left { border-left: 4px solid black !important; }
        .thick-right { border-right: 4px solid black !important; }
        .thick-bottom { border-bottom: 4px solid black !important; }




        pre {
            margin-top: 2rem;
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 1rem;
            width: 90%;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9rem;
        }


        #rulesModal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #rulesModalContent {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        #rulesModalContent p {
            text-align: left;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .rotating {
            display: inline-block;
            animation: rotate 2s linear infinite;
        }

    </style>
</head>
<body>
<div id="loadingOverlay" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
">

    <!-- Lade-GIF -->
    <img src="https://www.animierte-gifs.net/data/media/983/animiertes-biber-bild-0021.gif" border="0" alt="animiertes-biber-bild-0021" />

    <!-- Lade-Text mit wei√üem Hintergrund -->
    <div id="loader2" style="
        margin-top: 20px;
        background: white;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 24px;
        color: black;
        display: flex;
        align-items: center;
        gap: 10px;
    ">
        <span class="rotating">‚è≥</span> Lade Sudokus...
    </div>

</div>

<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div class="controls">
        <div class="button-group">
            <button id="grid4" onclick="setGridSize(4)">4x4</button>
            <button id="grid6" onclick="setGridSize(6)">6x6</button>
            <button id="grid9" onclick="setGridSize(9)">9x9</button>
        </div>

        <select id="modeSelector" onchange="changeMode()" style="display: none;">
            <option value="mark">Felder markieren</option>
            <option value="input">Zahlen eingeben</option>
        </select>

        <div>
            <button id="markBtn" onclick="selectMode('mark')">Felder markieren</button>
            <button id="inputBtn" onclick="selectMode('input')">Zahlen eingeben</button>
        </div>

        <div class="controls3">
            <button id="uploadBtn">Hintergrundbild hochladen</button>
            <input type="file" id="imageUpload" accept="image/*" style="display:none;">
            <button id="removeBg">Hintergrundbild entfernen</button>
        </div>

    </div>

    <div class="controls">
        <button onclick="showSudokuRules()">Sudoku-Regeln anzeigen</button>

        <p id="changeCounter" style="
    background: white;
    padding: 10px 20px;
    border-radius: 8px;
    display: inline-block;
">
            Markierte Felder: 0
        </p>
    </div>
</div>

<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
    <div class="controls">
        <div class="grid-wrapper">
            <div class="background" id="background"></div>
            <div class="grid" id="grid"></div>
        </div>

        <div class="controls2">
            <button onclick="createSudoku()">Sudoku erstellen</button>
            <button onclick="resetGrid()">Zur√ºcksetzen</button>
        </div>

    </div>

    <div class="controls">
        <svg xmlns="http://www.w3.org/2000/svg"  id="partialSvg" style="display:none;">
            <style>
                text { font-family: Arial, sans-serif; text-anchor: middle; fill: black; }
            </style>
        </svg>

        <div class="button-group">
            <button id="downloadBtn" onclick="downloadSudoku(partialSvg)" style="display:none; margin-top: 1rem;">download partial Sudoku</button>
            <button id="download filled sudoku" onclick="downloadSudoku(fullSvg)" style="display:none; margin-top: 1rem;">download filled Sudoku</button>
        </div>
    </div>
</div>






<svg xmlns="http://www.w3.org/2000/svg" width="450" height="450" viewBox="0 0 450 450" id="fullSvg" style="display:none;">
    <style>
        text { font-family: Arial, sans-serif; text-anchor: middle; fill: black; }
    </style>
</svg>




<div id="errorOutput" style="color:red; margin-top:10px;"></div>

<div id = "indices" style = "color:blue; margin-top:10px ;"></div>

<div id="rulesModal">
    <div id="rulesModalContent">
        <h2>Sudoku-Regeln</h2>
        <p>
            üîπ Jede Zahl darf nur einmal pro Zeile/Spalte/Block vorkommen.<br><br>
            üîπ Pro Dreier/Zweierblock an Spalten/Zeilen m√ºssen mindestens zwei beziehungsweise eine Spalte/Zeile einen Eintrag haben.<br><br>
            üîπ Bei 9x9 m√ºssen mindestens 17 Felder markiert werden<br><br>
            <b>Markierungsmodus:</b> Felder markieren.<br>
            <b>Eingabemodus:</b> Zahlen eingeben.<br><br>
        </p>
        <button onclick="closeRulesModal()" style="margin-top:1rem; padding:0.5rem 1rem; background:#3b82f6; color:white; border:none; border-radius:5px; cursor:pointer;">Schlie√üen</button>
    </div>
</div>




<script>
    let changes = 0;
    let currentSize = 9;
    let gridState = [];
    let markMode = true;
    document.getElementById("grid9").classList.add('active-mode')
    document.getElementById("markBtn").classList.add('active-mode')
    const gridElement = document.getElementById("grid");
    const modeSelector = document.getElementById("modeSelector");
    const serverUrl = "http://localhost:8080";
    const { jsPDF } = window.jspdf;
    const { svg2pdf } = window.svg2pdf;
    const partialSvg = document.getElementById('partialSvg');
    const fullSvg = document.getElementById('fullSvg');
    const uploadBtn = document.getElementById('uploadBtn');
    const imageUpload = document.getElementById('imageUpload');
    const removeBtn = document.getElementById('removeBg');
    const backgroundDiv = document.getElementById('background');
    let hasBackgroundImage = false;
    let imageURL;


    /*
    Entfernt das Hintergrundbild vom Sudoku
     */
    removeBtn.addEventListener('click', () => {
        backgroundDiv.style.backgroundImage = 'none';
        hasBackgroundImage = false;
    });


    uploadBtn.addEventListener('click', () => {
        imageUpload.click();  // √∂ffnet den Datei-Dialog
    });

    /*
    stellt Feld f√ºr Upload zur Verf√ºgung, um das Bild als Hintergrund zu benutzen
     */
    imageUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            backgroundDiv.style.backgroundImage = `url('${e.target.result}')`;
            imageURL = e.target.result;
            hasBackgroundImage = true;
        };
        reader.readAsDataURL(file);

        event.target.value = '';
    });


    function getBlockSize(size) {
        if (size === 4) return [2, 2];
        if (size === 6) return [2, 3];
        if (size === 9) return [3, 3];
        return [1, 1];
    }


    function createGrid(size) {
        const [blockRows, blockCols] = getBlockSize(size);
        gridElement.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        gridElement.innerHTML = '';
        gridState = Array(size * size).fill(0);

        for (let row = 0; row < size; row++) {
            for (let col = 0; col < size; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');

                if (row % blockRows === 0) cell.classList.add('thick-top');
                if (col % blockCols === 0) cell.classList.add('thick-left');
                if (col === size - 1) cell.classList.add('thick-right');
                if (row === size - 1) cell.classList.add('thick-bottom');

                const index = row * size + col;

                if (markMode === false) {
                    const input = document.createElement('input');
                    input.setAttribute('maxlength', '1');
                    input.setAttribute('type', 'text');
                    input.addEventListener('input', (e) => {
                        document.querySelectorAll(".cell").forEach(cell => {
                            cell.classList.remove(`error`);
                        });
                        const regex = new RegExp(`[^1-${currentSize}]`, 'g');
                        const val = e.target.value.replace(regex, '').slice(0, 1);
                        e.target.value = val;
                        gridState[index] = val ? parseInt(val, 10) : 0;  // ‚Üê Convert to number
                        if (val){
                            changes ++
                        }else{
                            changes --
                        }
                        updateChangeCounter();
                        dynamicErrors();
                    });
                    cell.appendChild(input);
                } else {
                    cell.addEventListener('click', () => {
                        document.querySelectorAll(".cell").forEach(cell => {
                            cell.classList.remove(`error`);
                        });
                        const marked = cell.classList.toggle('marked');
                        gridState[index] = marked ? 1 : 0;
                        if (marked){
                            changes ++
                        }else {
                            changes --
                        }
                        updateChangeCounter();
                        dynamicErrors();
                    });
                }

                gridElement.appendChild(cell);
            }
        }


    }

    function dynamicErrors(){
        const tupel = {
            size: currentSize,
            mode: markMode,
            state: [...gridState]
        };
        const errors = validTupel(tupel);
        highlightErrors(errors,tupel);
    }



    /*
    Updatet die Anzahl der markierten Felder
     */
    function updateChangeCounter() {
        document.getElementById("changeCounter").textContent = `Markierte Felder: ${changes}`;
    }


    /*
    Ver√§ndert die Grid Size, falls ein Button ausgew√§hlt wurde, welcher nicht aktiv ist
    Ruft danach Reset Grid auf
     */
    function setGridSize(size) {
        if(currentSize === size){
            return;
        }

        document.getElementById("grid4").classList.remove('active-mode')
        document.getElementById("grid9").classList.remove('active-mode')
        document.getElementById("grid6").classList.remove('active-mode')
        if (size === 4){
            document.getElementById("grid4").classList.add('active-mode')
        }else if (size === 6){
            document.getElementById("grid6").classList.add('active-mode')
        }else if (size === 9){
            document.getElementById("grid9").classList.add('active-mode')
        }

        currentSize = size;
        resetGrid();
    }

    /*
    Wird immer dann ausgef√ºhrt, wenn der Modus ge√§ndert wird
    Wenn der bereits aktivierte Button angeklickt wird, √§ndert sich nichts
    √Ñndert die Hervorhebung der Button und ruft Originalfunktion auf

     */
    function selectMode(mode) {
        if(modeSelector.value === mode){
            return;
        }
        modeSelector.value = mode;

        document.getElementById('markBtn').classList.remove('active-mode');
        document.getElementById('inputBtn').classList.remove('active-mode');

        if (mode === 'mark') {
            document.getElementById('markBtn').classList.add('active-mode');
        } else if (mode === 'input') {
            document.getElementById('inputBtn').classList.add('active-mode');
        }
        changeMode();
    }

    /*
    Setzt den Wert f√ºr markMode, welcher sp√§ter ans Backend √ºbergeben wird
    Ruft anschlie√üend Reset Grid auf
     */
    function changeMode() {
        if (modeSelector.value === "input"){
            markMode = false;
        }else if (modeSelector.value === "mark"){
            markMode = true
        }
        resetGrid();
    }

    /*
    resetet √Ñnderungszahl
    Verstekt die Download-Buttons, da nicht mehr am aktuellen Sudoku gearbeitet wird
     */
    function resetGrid() {
        changes = 0;
        updateChangeCounter();
        hideDownloadButton();
        partialSvg.style.display = "none";
        createGrid(currentSize);
    }


    /*
    Blendet die beiden Download-Button ein, immer dann wenn ein Sudoku generiert wurde
     */
    function showDownloadButton() {
        document.getElementById("downloadBtn").style.display = "block";
        document.getElementById("download filled sudoku").style.display = "block";
    }
    /*
    L√§sst die Button verschwinden, immer bei Reset
     */
    function hideDownloadButton() {
        document.getElementById("downloadBtn").style.display = "none";
        document.getElementById("download filled sudoku").style.display = "none";
    }

    function createSudoku() {
        partialSvg.style.display = "none";
        hideDownloadButton();


        const tupel = {
            size: currentSize,
            mode: markMode,
            state: [...gridState]
        };

        let errors = validTupel(tupel);
        if (changes <17 && tupel.size === 9){
            alert("markiere mindestens 17 Elemente")
        }else
        if (errors.length !== 0){
            alert("markiere Elemente bis nichts mehr rot ist")
        }else {
            document.getElementById('loadingOverlay').style.display = 'flex';

            console.log("Sudoku-Tupel:", tupel);
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById("downloadBtn").style.display = "none";
            const payload = {
                    data: gridState,
                    length: currentSize * currentSize,
                    markingmode: markMode,
        };
        fetch(`${serverUrl}/api/process-tuple`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(result => {
            if (result.hassolution === false) {
                alert("Das markierte Sudoku ist ung√ºltig!");
            } else {
                  renderSudoku(result.data, result.solution, partialSvg);
                  renderSudoku(result.data, result.solution, fullSvg);
                  partialSvg.style.display = "block";
                  showDownloadButton();
                }
            })
        .catch(error => {
            alert("Es ist ein Fehler aufgetreten: " + error.message);
            console.error("Error:", error);
        })
        .finally(() => {
            document.getElementById("loadingOverlay").style.display = "none";
        });

            console.log("Sudoku-Tupel:", tupel);
            document.getElementById("downloadBtn").style.display = "none";
        }

    }


    function validTupel(tupel) {
        const size = tupel.size;
        const values = tupel.state;
        const [blockRows, blockCols] = getBlockSize(size);
        const errors = [];

        // === MARK-MODUS PR√úFUNG ===
        if (tupel.mode === true) {
            const hasContent = values.some(v => v === 1);
            if (!hasContent) errors.push("Keine Felder markiert!");

            checkRowColDistribution(values, size, errors);
        }

        // === INPUT-MODUS PR√úFUNG ===
        if (tupel.mode === false) {
            const getCoordinates = (index) => {
                return `(${Math.floor(index / size) + 1}, ${index % size + 1})`;
            };

            const findDuplicates = (group, groupType, groupIndex) => {
                const seen = {};
                for (let i = 0; i < group.length; i++) {
                    const val = group[i];
                    if (val !== "0" && val !== "") {
                        if (seen[val] !== undefined && val !== 0) {
                            const firstIndex = seen[val];
                            const secondIndex = i;
                            let x = secondIndex % size + 1
                            let y = firstIndex % size + 1
                            if (groupType === "Zeile"){
                                errors.push(["E",(groupIndex + 1)*size + y - (size +1), (groupIndex + 1)*size + x -(size+1)])
                            }else if (groupType === "Spalte"){
                                errors.push(["E",y * size + groupIndex +1 - (size +1),x * size + groupIndex +1 - (size + 1)]);
                            }
                            //errors.push(`Doppelte Zahl '${val}' in ${groupType} ${groupIndex + 1} an Positionen ${getCoordinates(firstIndex)} und ${getCoordinates(secondIndex)}`);
                        } else {
                            seen[val] = i;
                        }
                    }
                }
            };

            // Zeilen pr√ºfen
            for (let row = 0; row < size; row++) {
                const rowVals = [];
                for (let col = 0; col < size; col++) {
                    const index = row * size + col;
                    rowVals.push(values[index]);
                }
                findDuplicates(rowVals, "Zeile", row);
            }

            // Spalten pr√ºfen
            for (let col = 0; col < size; col++) {
                const colVals = [];
                for (let row = 0; row < size; row++) {
                    const index = row * size + col;
                    colVals.push(values[index]);
                }
                findDuplicates(colVals, "Spalte", col);
            }

            // Bl√∂cke pr√ºfen
            for (let blockRow = 0; blockRow < size; blockRow += blockRows) {
                for (let blockCol = 0; blockCol < size; blockCol += blockCols) {
                    const blockVals = [];
                    const blockIndexes = [];
                    for (let r = 0; r < blockRows; r++) {
                        for (let c = 0; c < blockCols; c++) {
                            const row = blockRow + r;
                            const col = blockCol + c;
                            const index = row * size + col;
                            blockVals.push(values[index]);
                            blockIndexes.push(index);
                        }
                    }
                    const seen = {};
                    for (let i = 0; i < blockVals.length; i++) {
                        const val = blockVals[i];
                        if (val !== "0" && val !== "") {
                            if (seen[val] !== undefined && val !== 0) {
                                const firstIndex = blockIndexes[seen[val]];
                                const secondIndex = blockIndexes[i];
                                //errors.push(`Doppelte Zahl '${val}' im Block (${Math.floor(blockRow/blockRows)+1}, ${Math.floor(blockCol/blockCols)+1}) an ${getCoordinates(firstIndex)} und ${getCoordinates(secondIndex)}`);
                                errors.push(["E",coordinatesToList(size,getCoordinates(firstIndex)),coordinatesToList(size,getCoordinates(secondIndex))]);
                            } else {
                                seen[val] = i;
                            }
                        }
                    }
                }
            }

            // Verteilung pr√ºfen
            checkRowColDistribution(values, size, errors);
        }

        return errors;
    }

    function coordinatesToList(size,coordinates){
        const [row, col] = coordinates
            .slice(1, -1)
            .split(',')
            .map(s => parseInt(s));
        return (row - 1) * size + col -1
    }

    function checkRowColDistribution(values, size, errors) {
        let blockSize = size === 9 ? 3 : size === 6 || 4 ? 2 : 1;

        // Zeilenbl√∂cke pr√ºfen
        for (let i = 0; i < size; i += blockSize) {
            let filledRows = 0;
            let emptyRows = []; // Sammeln, welche Zeilen leer sind
            for (let r = i; r < i + blockSize; r++) {
                const hasEntry = values.slice(r * size, (r + 1) * size).some(v => v !== 0 && v !== "0" && v !== "");
                if (hasEntry) {
                    filledRows++;
                } else {
                    emptyRows.push(r + 1); // Zeilennummer speichern (beginnend bei 1)
                }
            }
            if ((blockSize === 3 && filledRows < 2) || (blockSize === 2 && filledRows < 1)) {
                //errors.push(`Zu wenig markierte/ausgef√ºllte Zeilen im Block ${i / blockSize + 1}: fehlende Zeilen ${emptyRows.join(", ")}`);
                errors.push(["Z",emptyRows]);
            }
        }

        // Spaltenbl√∂cke pr√ºfen
        if (size === 6){
            blockSize = 3
        }
        for (let i = 0; i < size; i += blockSize) {
            let filledCols = 0;
            let emptyCols = []; // Sammeln, welche Spalten leer sind
            for (let c = i; c < i + blockSize; c++) {
                let hasEntry = false;
                for (let r = 0; r < size; r++) {
                    const index = r * size + c;
                    if (values[index] !== 0 && values[index] !== "0" && values[index] !== "") {
                        hasEntry = true;
                        break;
                    }
                }
                if (hasEntry) {
                    filledCols++;
                } else {
                    emptyCols.push(c + 1); // Spaltennummer speichern (beginnend bei 1)
                }
            }
            if ((blockSize === 3 && filledCols < 2) || (blockSize === 2 && filledCols < 1)) {
                //errors.push(`Zu wenig markierte/ausgef√ºllte Spalten im Block ${i / blockSize + 1}: fehlende Spalten ${emptyCols.join(", ")}`);
                errors.push(["S",emptyCols])
            }
        }

        return errors;
    }

    function highlightErrors(errors,tupel) {
        let errorindices = new Set

        // Vorherige Fehler zur√ºcksetzen
        document.querySelectorAll(".cell").forEach(cell => {
            cell.classList.remove(`error`);
        });

        document.addEventListener('DOMContentLoaded', () => {
            gridState = Array.from(document.querySelectorAll('#grid .cell'));
        });

        let size = tupel.size;
        errors.forEach(error => {
            switch (error[0]) {
                case "Z": { // Mehrere Zeilen
                    const rows = error[1];
                    rows.forEach(row => {
                        for (let col = 0; col < size; col++) {
                            const index = (row-1) * size + col;
                            errorindices.add(index);
                        }
                    });
                    break;
                }
                case "S": { // Mehrere Spalten
                    const cols = error[1];
                    cols.forEach(col => {
                        const c = col - 1;
                        for (let row = 0; row < size; row++) {
                            const index = row * size + c;
                            errorindices.add(index);
                        }
                    });
                    break;
                }
                case "E": { // Einzelnes Element
                    errorindices.add(error[1]);
                    errorindices.add(error[2]);
                    break;
                }
            }
            applyErrors(errorindices);

        });
        const indicesDiv = document.getElementById("indices");
        indicesDiv.innerHTML = "<strong>Indizes</strong>:</strong><br>" + errorIndices.join("<br>");
    }

    function applyErrors(indices){
        const cells = document.querySelectorAll("#grid .cell");
        indices.forEach(index => {
            const cell = cells[index];
            if (cell) {
                cell.classList.add("error"); // Markiere Fehler
            }
        });
    }

    /*
    macht aus dem Hintergrundbild ein schwarz wei√ü Bild, damit im PDF sp√§ter der Hintergrund auch schwarz wei√ü ist
     */
    function convertImageToGrayscale(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const avg = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    data[i] = data[i + 1] = data[i + 2] = avg;
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL());
            };
            img.onerror = reject;
            img.src = src;
        });
    }

    /*Zeichnet das partielle Sudoku als Vektorgraphik
    macht die markierten Felder grau
    unterscheidet zwischen voll und partiell
    Aktuell noch nur auf 9*9
     */
    async function renderSudoku(data, solution, svg) {
        while (svg.childNodes.length > 1) {
            svg.removeChild(svg.lastChild);
        }

        if(hasBackgroundImage){
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
            pattern.setAttribute("id", "bgImage");
            pattern.setAttribute("patternUnits", "userSpaceOnUse");
            pattern.setAttribute("width", 50 * currentSize);
            pattern.setAttribute("height", 50 * currentSize);

            const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
            const grayDataURL = await convertImageToGrayscale(imageURL);
            image.setAttributeNS(null, "href", grayDataURL);
            image.setAttribute("width", 50 * currentSize);
            image.setAttribute("height", 50 * currentSize);
            image.setAttribute("preserveAspectRatio", "xMidYMid slice");

            pattern.appendChild(image);
            defs.appendChild(pattern);
            svg.appendChild(defs);
        }
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

        rect.setAttribute('x', 0);
        rect.setAttribute('y', 0);
        rect.setAttribute('width', 50 * currentSize);
        rect.setAttribute('height', 50 * currentSize);
        rect.setAttribute("fill", "white");
        svg.appendChild(rect);

        if (hasBackgroundImage) {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

            rect.setAttribute('x', 0);
            rect.setAttribute('y', 0);
            rect.setAttribute('width', 50 * currentSize);
            rect.setAttribute('height', 50 * currentSize);
            rect.setAttribute("fill", "url(#bgImage)");
            svg.appendChild(rect);
        }

        for (let row = 0; row < currentSize; row++) {
            for (let col = 0; col < currentSize; col++) {
                let x = col * 50;
                let y = row * 50;
                let index = row * currentSize + col;

                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", y);
                rect.setAttribute("width", 50);
                rect.setAttribute("height", 50);
                rect.setAttribute("class", "cell");
                rect.setAttribute("fill", "rgba(255, 255, 255, 0.5)");
                rect.setAttribute("stroke", "black");
                rect.setAttribute("stroke-width", "1");

                if (data[index] !== 0 && !hasBackgroundImage) {
                    rect.setAttribute("fill", "rgba(128, 128, 128, 0.3)");
                }
                svg.appendChild(rect);


                if (data[index] !== 0 || svg === fullSvg) {
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");

                    text.setAttribute("x", x + 25);
                    text.setAttribute("y", y + 38);
                    text.setAttribute("font-size", "40px");
                    text.setAttribute("text-anchor", "middle");
                    text.textContent = solution[index];
                    text.setAttribute("fill", "black");
                    svg.appendChild(text);


                }
            }
        }
        let lines = [];

        if (currentSize === 9) {
            lines = [
                {x1: 0, y1: 150, x2: 450, y2: 150},
                {x1: 0, y1: 300, x2: 450, y2: 300},
                {x1: 150, y1: 0, x2: 150, y2: 450},
                {x1: 300, y1: 0, x2: 300, y2: 450},
            ];
            svg.setAttribute('viewBox', `0 0 450 450`);
            svg.setAttribute('width', '450');
            svg.setAttribute('height', '450');
        } else if (currentSize === 6) {
            lines = [
                {x1: 0, y1: 100, x2: 300, y2: 100},
                {x1: 0, y1: 200, x2: 300, y2: 200},
                {x1: 150, y1: 0, x2: 150, y2: 300},
            ];
            svg.setAttribute('viewBox', `0 0 300 300`);
            svg.setAttribute('width', '300');
            svg.setAttribute('height', '300');
        } else {
            lines = [
                {x1: 0, y1: 100, x2: 200, y2: 100},
                {x1: 100, y1: 0, x2: 100, y2: 200},
            ];
            svg.setAttribute('viewBox', `0 0 200 200`);
            svg.setAttribute('width', '200');
            svg.setAttribute('height', '200');
        }

        lines.forEach(lineData => {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", lineData.x1);
            line.setAttribute("y1", lineData.y1);
            line.setAttribute("x2", lineData.x2);
            line.setAttribute("y2", lineData.y2);
            line.setAttribute("stroke", "black");
            line.setAttribute("stroke-width", "3");   // dickere Linien f√ºr Unterquadrate
            svg.appendChild(line);
        });

        const border = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        border.setAttribute("x", 0);
        border.setAttribute("y", 0);
        border.setAttribute("width", 50 * currentSize);
        border.setAttribute("height", 50 * currentSize);
        border.setAttribute("fill", "none");
        border.setAttribute("stroke", "black");
        border.setAttribute("stroke-width", 8);   // noch dickerer Rahmen au√üen
        svg.appendChild(border);
    }

    /*
    Funktion um das PDF zu downloaden
    Mit svg kann man angeben ob das volle oder nur das partielle
     */
    async function downloadSudoku(svg) {
        const pdf = new jsPDF({ unit: 'pt', format: [50*currentSize, 50*currentSize] });

        pdf.setFillColor(255, 255, 255);
        pdf.rect(0, 0, 50*currentSize, 50*currentSize, 'F');

        svg.style.display = "block";
        await svg2pdf(svg, pdf, { x: 0, y: 0, scale: 1 });
        if(svg === fullSvg){
            svg.style.display = "none";
            pdf.save("solution.pdf");
            return;
        }
        pdf.save("sudoku.pdf");
    }

    createGrid(currentSize);

    function showSudokuRules() {
        document.getElementById("rulesModal").style.display = "flex";
    }

    function closeRulesModal() {
        document.getElementById("rulesModal").style.display = "none";
    }

    document.getElementById("rulesModal").addEventListener("click", function(e) {
        if (e.target.id === "rulesModal") {
            closeRulesModal();
        }
    });

</script>
</body>
</html>